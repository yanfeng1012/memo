## 设计模式

- 转移

>转移是两个状态之间的一种关系，表示对象在源状态中执行一定的动作，并在某个特定时间在发生且某个特定的境界条件满足时进入目标状态。转移有两个状态，原状态和目标状态。

- 命令模式

>将一个请求封装为一个对象，从而可以用不同的请求对客户进行参数化。

- 责任链模式

>使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。

- 观察者模式

>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有的依赖于它的对象都得到通知并被自动更新。

- 策略模式

>定义一系列的算法，把每一个算法封装起来，并且他们可以相互替换。本模式使得算法可以独立于使用它的客户而变化。

- 建造者模式（生成器模式）

>将一个复杂对象的构建与它的标识分离，使得同样的构建过程可以创建不同的表示。建造者模式将部件和其组装过程分开，一步一步创建一个复杂的对象。

- 工厂方法

>也叫做虚拟构造器模式，它定义一个用于创建对象的接口，让子类决定实例化哪一个类，使一个类的实例化延迟到其子类。

- 原型模式

>用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。

- 单例模式

>确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，他提供全局访问的方法。

- 桥接

>桥接模式即将抽象部分与它的实现部分分离开来，使他们都可以独立变化。结构性对象模式

- [访问者模式](https://www.jianshu.com/p/1f1049d0a0f4)

>对象结构比较稳定，但经常需要在此对象结构上定义新的操作。

>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免这些操作“污染”这些对象的类，也不希望在增加新操作时修改这些类。

- 装饰器模式

>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。

- 外观模式

>外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。

- 享元模式

>提供支持大量细粒度对象共享的有效方法。

- 组合模式

>组合(Composite)模式将对象组合成树形结构以表示“部分整体”的层次结构，使得用
户对单个对象和组合对象的使用具有一致性。

>适用于:想表示对象的部分-整体层次结构; 希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。

- 中介者模式

> 中介者(Mediator)用一个中介对象来封装一系列的对象交互。 

> 中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。

> 适用于:一组对象以定义良好但是复杂的方式进行通信，产生的相互依赖关系结构混乱且难以理解;一个对象引用其他很多对象并且直接与这些对象通信，导致难以复用该对象;想定制一一个分布在多个类中的行为，而又不想生成太多的子类。

> 欲使一个后端数据模型能够被多个前端用户界面连接，采用中介者模式最合适。